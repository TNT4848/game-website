<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Flight Sim ðŸš€</title>
<style>
body { margin: 0; overflow: hidden; background: #87ceeb; }
#hud {
Â Â position: absolute; top: 8px; left: 8px; color: #fff; font-family: monospace;
Â Â background: rgba(0,0,0,0.25); padding: 8px; border-radius: 6px;
}
#instructions {
Â Â position: absolute; right: 8px; top: 8px; color:#fff;
Â Â background:rgba(0,0,0,0.25); padding:8px; border-radius:6px;
Â Â font-family: sans-serif; display: none;
}
#overlay {
Â Â position: absolute; top:0; left:0; right:0; bottom:0;
Â Â display:flex; align-items:center; justify-content:center;
Â Â background: rgba(0,0,0,0.6); color:white; font-size:24px;
Â Â cursor:pointer; user-select:none;
}
#crashMsg {
Â Â position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
Â Â font-size: 40px; color: red; font-weight: bold; display: none;
Â Â text-shadow: 2px 2px 8px black;
}
</style>
</head>
<body>
<div id="hud">Throttle: 0%<br>Speed: 0 m/s<br>Altitude: 0 m<br>Weapon: Minigun<br>
Press <b>P</b> to Respawn
</div>
<div id="instructions">
S : Pitch Up<br>
W : Pitch Down<br>
A/D : Roll<br>
1 : Yaw Left<br>
2 : Yaw Right<br>
R/F : Throttle Up/Down<br>
Space : Fire Weapon<br>
Q : Switch Weapon<br>
H : Toggle Controls
</div>
<div id="overlay">Click to Start</div>
<div id="crashMsg">ðŸ’¥ CRASHED!</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87ceeb, 0.0006);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100000);
camera.position.set(0, 5, -15);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.9));
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(-100,200,100);
scene.add(dir);

// Ground
const groundMat = new THREE.MeshLambertMaterial({color:0x2d8f2d});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(20000,20000), groundMat);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Grid
const gridHelper = new THREE.GridHelper(20000, 200, 0x000000, 0x555555);
scene.add(gridHelper);

// Plane
const plane = new THREE.Group();
const fus = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,4,8), new THREE.MeshPhongMaterial({color:0xffaa00}));
fus.rotation.z = Math.PI/2; plane.add(fus);
const wing = new THREE.Mesh(new THREE.BoxGeometry(6,0.15,1.5), new THREE.MeshPhongMaterial({color:0x888888})); plane.add(wing);
const tail = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.15,1), new THREE.MeshPhongMaterial({color:0x888888}));
tail.position.set(-1.7,0.7,0); plane.add(tail);
const prop = new THREE.Mesh(new THREE.BoxGeometry(0.1,2,0.04), new THREE.MeshPhongMaterial({color:0x333333}));
prop.position.set(2.2,0,0); plane.add(prop);
plane.scale.set(1.5,1.5,1.5); scene.add(plane);

// Towers
let towerDistance = 1200; 
const towerGeometry = new THREE.BoxGeometry(10,200,10);
function createTower(x,z){
Â Â const material = new THREE.MeshPhongMaterial({color:0x888888});
Â Â const mesh = new THREE.Mesh(towerGeometry,material);
Â Â mesh.position.set(x,100,z);
Â Â mesh.userData.bbox = new THREE.Box3().setFromObject(mesh);
Â Â scene.add(mesh);
Â Â return {mesh, debris: []};
}
let towers = [createTower(towerDistance-15,-10), createTower(towerDistance+15,10)];

// Projectiles
const projectiles = [];

const state = {
Â Â pos: new THREE.Vector3(0,30,0),
Â Â vel: new THREE.Vector3(40,0,0),
Â Â quat: new THREE.Quaternion(),
Â Â throttle: 0.5,
Â Â mass: 1200,
Â Â wingArea:16,
Â Â liftCoeff0:0.2,
Â Â liftSlope:5.0,
Â Â dragCoeff:0.02,
Â Â airDensity:1.225,
Â Â crashed:false,
Â Â weaponIndex:0,
Â Â weaponNames:['Minigun','Rockets','Bombs'],
Â Â ammo:[250,15,8]
};
state.quat.setFromEuler(new THREE.Euler(0,0,0));

const camOffset = new THREE.Vector3(-15,6,0);
const keys = {};
let controlsActive=false;

const overlay=document.getElementById("overlay");
const instructionsBox=document.getElementById("instructions");
const crashMsg=document.getElementById("crashMsg");
const hud=document.getElementById("hud");

overlay.addEventListener("click",()=>{
Â Â controlsActive=true;
Â Â overlay.style.display="none";
Â Â crashMsg.style.display="none";
Â Â window.addEventListener('keydown', e=>{
Â Â Â Â keys[e.key.toLowerCase()]=true;
Â Â Â Â if(e.key.toLowerCase()==='h') instructionsBox.style.display = instructionsBox.style.display==="none"?"block":"none";
Â Â Â Â if(e.key.toLowerCase()==='q') state.weaponIndex=(state.weaponIndex+1)%3;
Â Â Â Â if(e.key===' ') fireWeapon();
Â Â Â Â if(e.key.toLowerCase()==='p') resetPlane();
Â Â });
Â Â window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()]=false;});
});

window.addEventListener('resize',()=>{
Â Â camera.aspect=innerWidth/innerHeight;
Â Â camera.updateProjectionMatrix();
Â Â renderer.setSize(innerWidth,innerHeight);
});

function forwardVector(q){return new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();}
function upVector(q){return new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();}

function resetPlane(){
Â Â state.pos.set(0,30,0);
Â Â state.vel.set(40,0,0);
Â Â state.quat.setFromEuler(new THREE.Euler(0,0,0));
Â Â state.throttle=0.5;
Â Â state.crashed=false;
Â Â state.ammo=[250,15,8];
Â Â crashMsg.style.display="none";
Â Â projectiles.length=0;
Â Â towers.forEach(t=>{
Â Â Â Â if(!t.mesh) t.mesh=createTower(towerDistance-15, -10).mesh;
Â Â Â Â t.mesh.material.color.set(0x888888);
Â Â Â Â t.debris.forEach(d=>scene.remove(d));
Â Â Â Â t.debris=[];
Â Â });
}

function fireWeapon(){
Â Â if(state.crashed) return;
Â Â if(state.ammo[state.weaponIndex]<=0) return;
Â Â state.ammo[state.weaponIndex]--;
Â Â const dir=forwardVector(state.quat).clone();
Â Â const pos=state.pos.clone().add(dir.clone().multiplyScalar(5));
Â Â projectiles.push({
Â Â Â Â pos,dir,
Â Â Â Â speed:state.weaponIndex===0?500:state.weaponIndex===1?300:200,
Â Â Â Â mesh:createProjectileMesh(pos,state.weaponIndex===0?0xffff00:state.weaponIndex===1?0xff0000:0x0000ff)
Â Â });
}

function createProjectileMesh(pos,color){
Â Â const geom=new THREE.SphereGeometry(0.5,6,6);
Â Â const mat=new THREE.MeshBasicMaterial({color});
Â Â const mesh=new THREE.Mesh(geom,mat);
Â Â mesh.position.copy(pos);
Â Â scene.add(mesh);
Â Â return mesh;
}

function createDebris(pos){
Â Â const geom=new THREE.BoxGeometry(2,2,2);
Â Â const mat=new THREE.MeshPhongMaterial({color:0x888888});
Â Â const mesh=new THREE.Mesh(geom,mat);
Â Â mesh.position.copy(pos);
Â Â mesh.userData.vel=new THREE.Vector3((Math.random()-0.5)*5,Math.random()*5+2,(Math.random()-0.5)*5);
Â Â scene.add(mesh);
Â Â return mesh;
}

function explodeTower(t){
Â Â if(!t.mesh) return;
Â Â for(let d=0; d<30; d++) t.debris.push(createDebris(t.mesh.position.clone()));
Â Â scene.remove(t.mesh);
Â Â t.mesh=null;
Â Â towers.forEach(other=>{if(other!==t) explodeTower(other);});
}

let last=performance.now();
function animate(now){
Â Â const dt=Math.min(0.05,(now-last)/1000);
Â Â last=now;

Â Â if(controlsActive && !state.crashed){
Â Â Â Â const pitchInput=(keys['w']?1:0)-(keys['s']?1:0);
Â Â Â Â const rollInput=(keys['d']?1:0)-(keys['a']?1:0);
Â Â Â Â const yawInput=(keys['1']?1:0)-(keys['2']?1:0); // Yaw on 1/2 keys

Â Â Â Â if(keys['r']) state.throttle=Math.min(1,state.throttle+dt*0.3);
Â Â Â Â if(keys['f']) state.throttle=Math.max(0,state.throttle-dt*0.3);

Â Â Â Â const pitchRate=1.1*pitchInput;
Â Â Â Â const rollRate=1.1*rollInput;
Â Â Â Â const yawRate=1.1*yawInput;
Â Â Â Â const dq=new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchRate*dt,yawRate*dt,rollRate*dt));
Â Â Â Â state.quat.multiply(dq).normalize();

Â Â Â Â const forward=forwardVector(state.quat);
Â Â Â Â const speed=state.vel.length();
Â Â Â Â state.vel.copy(forward.multiplyScalar(speed));
Â Â }

Â Â if(!state.crashed){
Â Â Â Â const forward=forwardVector(state.quat);
Â Â Â Â const speed=state.vel.length();
Â Â Â Â const velDir=state.vel.clone().normalize();
Â Â Â Â let aoa=0;
Â Â Â Â if(speed>1e-3){ aoa=Math.asin(upVector(state.quat).dot(velDir)*-1); aoa=Math.max(-Math.PI/6, Math.min(Math.PI/3, aoa)); }
Â Â Â Â const Cl=state.liftCoeff0+state.liftSlope*aoa;
Â Â Â Â const lift=0.5*state.airDensity*speed*speed*state.wingArea*Cl;
Â Â Â Â const liftForce=upVector(state.quat).clone().multiplyScalar(lift);
Â Â Â Â const thrust=forward.clone().multiplyScalar(state.throttle*5000);
Â Â Â Â const drag=state.vel.clone().multiplyScalar(-state.dragCoeff*speed);
Â Â Â Â const gravity=new THREE.Vector3(0,-9.81*state.mass,0);
Â Â Â Â const totalForce=new THREE.Vector3().add(liftForce).add(thrust).add(drag).add(gravity);
Â Â Â Â const accel=totalForce.clone().multiplyScalar(1/state.mass);
Â Â Â Â state.vel.add(accel.multiplyScalar(dt));
Â Â Â Â state.pos.add(state.vel.clone().multiplyScalar(dt));

Â Â Â Â // Bounding boxes
Â Â Â Â const planeBBox = new THREE.Box3().setFromObject(plane);

Â Â Â Â if(state.pos.y<=1){state.crashed=true; crashMsg.style.display="block";}

Â Â Â Â towers.forEach(t=>{
Â Â Â Â Â Â if(t.mesh){
Â Â Â Â Â Â Â Â t.mesh.userData.bbox.setFromObject(t.mesh);
Â Â Â Â Â Â Â Â if(planeBBox.intersectsBox(t.mesh.userData.bbox)){ explodeTower(t); state.crashed=true; crashMsg.style.display="block"; }
Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â plane.position.copy(state.pos); plane.quaternion.copy(state.quat);
Â Â Â Â prop.rotation.x+=speed*dt*0.2;

Â Â Â Â const camWorldOffset=camOffset.clone().applyQuaternion(state.quat);
Â Â Â Â const desiredCamPos=state.pos.clone().add(camWorldOffset);
Â Â Â Â camera.position.lerp(desiredCamPos,1-Math.pow(0.001,dt));
Â Â Â Â camera.lookAt(state.pos.clone().add(forward.clone().multiplyScalar(20)));

Â Â Â Â // Projectiles
Â Â Â Â for(let i=projectiles.length-1;i>=0;i--){
Â Â Â Â Â Â const p=projectiles[i];
Â Â Â Â Â Â p.pos.add(p.dir.clone().multiplyScalar(p.speed*dt));
Â Â Â Â Â Â p.mesh.position.copy(p.pos);
Â Â Â Â Â Â towers.forEach(t=>{
Â Â Â Â Â Â Â Â if(t.mesh && t.mesh.userData.bbox.containsPoint(p.pos)){ 
Â Â Â Â Â Â Â Â Â Â explodeTower(t); 
Â Â Â Â Â Â Â Â Â Â scene.remove(p.mesh); 
Â Â Â Â Â Â Â Â Â Â projectiles.splice(i,1);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â });
Â Â Â Â Â Â if(p.pos.distanceTo(state.pos)>5000){ scene.remove(p.mesh); projectiles.splice(i,1); }
Â Â Â Â }

Â Â Â Â towers.forEach(t=>{ t.debris.forEach(d=>{ d.position.add(d.userData.vel.clone().multiplyScalar(dt)); d.userData.vel.add(new THREE.Vector3(0,-9.81*dt,0)); if(d.position.y<0)d.position.y=0; }); });
Â Â }

Â Â hud.innerHTML=`Throttle: ${Math.round(state.throttle*100)}%<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Speed: ${Math.round(state.vel.length())} m/s<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Altitude: ${Math.round(state.pos.y)} m<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Weapon: ${state.weaponNames[state.weaponIndex]}<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Ammo: ${state.ammo[state.weaponIndex]}<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Press <b>P</b> to Respawn`;

Â Â requestAnimationFrame(animate);
Â Â renderer.render(scene,camera);
}
requestAnimationFrame(animate);
</script>
</body>
</html>